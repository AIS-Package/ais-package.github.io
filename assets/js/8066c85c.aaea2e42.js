"use strict";(self.webpackChunkais_package_github_io=self.webpackChunkais_package_github_io||[]).push([[8794],{4796:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"advanced-guides/base-classes-reference/ina/ainet","title":"Artificial Immune Network Base","description":"Base class for Network Theory algorithms based on AiNet.","source":"@site/versioned_docs/version-0.3.x/advanced-guides/base-classes-reference/ina/ainet.md","sourceDirName":"advanced-guides/base-classes-reference/ina","slug":"/advanced-guides/base-classes-reference/ina/ainet","permalink":"/docs/0.3.x/advanced-guides/base-classes-reference/ina/ainet","draft":false,"unlisted":false,"tags":[],"version":"0.3.x","lastUpdatedBy":"Jo\xe3o Paulo","lastUpdatedAt":1759068822000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Artificial Immune Network Base","sidebar_label":"Artificial Immune Network","lastUpdatedAt":"2025/05/25","author":"Jo\xe3o Paulo","keywords":["AiNet","Immune Network Theory","Clustering","BaseAiNet","Artificial Immune Systems","Antibodies"]},"sidebar":"docs","previous":{"title":"Immune Network Algorithms","permalink":"/docs/0.3.x/advanced-guides/base-classes-reference/ina/"},"next":{"title":"Negative Selection","permalink":"/docs/0.3.x/advanced-guides/Core/negative-selection"}}');var i=s(4848),t=s(8453);const a={sidebar_position:1,title:"Artificial Immune Network Base",sidebar_label:"Artificial Immune Network",lastUpdatedAt:"2025/05/25",author:"Jo\xe3o Paulo",keywords:["AiNet","Immune Network Theory","Clustering","BaseAiNet","Artificial Immune Systems","Antibodies"]},c=void 0,d={},o=[{value:"<code>BaseAiNet(BaseClusterer, ABC)</code>",id:"BaseAiNetBaseClusterer-ABC",level:2},{value:"def _check_and_raise_exceptions_fit(...)",id:"def-_check_and_raise_exceptions_fit",level:3},{value:"def _check_and_raise_exceptions_predict(...)",id:"def-_check_and_raise_exceptions_predict",level:3},{value:"def _generate_random_antibodies(...)",id:"def-_generate_random_antibodies",level:3}];function l(e){const n={annotation:"annotation",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",math:"math",mo:"mo",mrow:"mrow",p:"p",pre:"pre",semantics:"semantics",span:"span",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Base class for Network Theory algorithms based on AiNet."}),"\n",(0,i.jsx)(n.h2,{id:"BaseAiNetBaseClusterer-ABC",children:(0,i.jsx)(n.code,{children:"BaseAiNet(BaseClusterer, ABC)"})}),"\n",(0,i.jsx)(n.p,{children:"The base class contains functions that are used by multiple classes in the AiNet package and\nare considered essential for proper functioning of clustering algorithms based on immune network theory."}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"def-_check_and_raise_exceptions_fit",children:"def _check_and_raise_exceptions_fit(...)"}),"\n",(0,i.jsx)(n.p,{children:"Verify the fit parameters and throw exceptions if the verification is not successful."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"@staticmethod\ndef _check_and_raise_exceptions_fit(X: npt.NDArray)\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"X"})})," (",(0,i.jsx)(n.code,{children:"npt.NDArray"}),"): Training array, containing the samples and their characteristics, [",(0,i.jsx)(n.code,{children:"N samples"})," (rows)][",(0,i.jsx)(n.code,{children:"N features"})," (columns)]."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Raises"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TypeError"}),": If X is not an ndarray or list."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"def-_check_and_raise_exceptions_predict",children:"def _check_and_raise_exceptions_predict(...)"}),"\n",(0,i.jsx)(n.p,{children:"Verify the predict parameters and throw exceptions if the verification is not successful."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'@staticmethod\ndef _check_and_raise_exceptions_predict(\n    X: npt.NDArray,\n    expected: int = 0,\n    feature_type: FeatureType = "continuous-features"\n) -> None\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"X"})})," (",(0,i.jsx)(n.code,{children:"npt.NDArray"}),"): Input array for prediction, containing the samples and their characteristics, [",(0,i.jsx)(n.code,{children:"N samples"})," (rows)][",(0,i.jsx)(n.code,{children:"N features"})," (columns)]."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"expected"})})," (",(0,i.jsx)(n.code,{children:"int"}),", default=0): Expected number of features per sample (columns in X)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"feature_type"})})," (",(0,i.jsx)(n.code,{children:"FeatureType"}),', default="continuous-features"): Specifies the type of features: "continuous-features", "binary-features", or "ranged-features".']}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Raises"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TypeError"}),": If X is not an ndarray or list."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"FeatureDimensionMismatch"}),": If the number of features in X does not match the expected number."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ValueError"}),': If feature_type is "binary-features" and X contains values other than 0 and 1.']}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"def-_generate_random_antibodies",children:"def _generate_random_antibodies(...)"}),"\n",(0,i.jsx)(n.p,{children:"Generate a random antibody population."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'@staticmethod\ndef _generate_random_antibodies(\n    n_samples: int,\n    n_features: int,\n    feature_type: FeatureType = "continuous-features",\n    bounds: Optional[npt.NDArray[np.float64]] = None\n) -> npt.NDArray\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"n_samples"})})," (",(0,i.jsx)(n.code,{children:"int"}),"): Number of antibodies (samples) to generate."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"n_features"})})," (",(0,i.jsx)(n.code,{children:"int"}),"): Number of features (dimensions) for each antibody."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"feature_type"})})," (",(0,i.jsx)(n.code,{children:"FeatureType"}),', default="continuous-features"): Specifies the type of features: "continuous-features", "binary-features", or "ranged-features".']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"bounds"})})," (",(0,i.jsx)(n.code,{children:"Optional[npt.NDArray[np.float64]]"}),"): Array of shape (n_features, 2) with min and max per dimension (used only for ranged features)."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"npt.NDArray"}),": Array of shape (n_samples, n_features) containing the generated antibodies.\nData type depends on the feature_type (float for continuous/ranged, bool for binary)."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Raises"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ValueError"}),": If n_features ",(0,i.jsxs)(n.span,{className:"katex",children:[(0,i.jsx)(n.span,{className:"katex-mathml",children:(0,i.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(n.semantics,{children:[(0,i.jsxs)(n.mrow,{children:[(0,i.jsx)(n.mo,{children:"<"}),(0,i.jsx)(n.mo,{children:"="})]}),(0,i.jsx)(n.annotation,{encoding:"application/x-tex",children:"<="})]})})}),(0,i.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(n.span,{className:"base",children:[(0,i.jsx)(n.span,{className:"strut",style:{height:"0.5782em",verticalAlign:"-0.0391em"}}),(0,i.jsx)(n.span,{className:"mrel",children:"<="})]})})]})," 0."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>c});var r=s(6540);const i={},t=r.createContext(i);function a(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);