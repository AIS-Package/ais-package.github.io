"use strict";(self.webpackChunkais_package_github_io=self.webpackChunkais_package_github_io||[]).push([[1524],{5562:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>t,contentTitle:()=>c,default:()=>o,frontMatter:()=>d,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"advanced-guides/Utils/Validation","title":"Validation","description":"def detectvectordata_type(...)","source":"@site/versioned_docs/version-0.5.x/advanced-guides/Utils/Validation.md","sourceDirName":"advanced-guides/Utils","slug":"/advanced-guides/Utils/Validation","permalink":"/docs/advanced-guides/Utils/Validation","draft":false,"unlisted":false,"tags":[],"version":"0.5.x","lastUpdatedBy":"Jo\xe3o Paulo","lastUpdatedAt":1763764227000,"frontMatter":{},"sidebar":"docs","previous":{"title":"Sanitizers","permalink":"/docs/advanced-guides/Utils/Sanitizers"},"next":{"title":"About us","permalink":"/docs/about-us"}}');var a=s(4848),i=s(8453);const d={},c="Validation",t={},l=[{value:"def detect_vector_data_type(...)",id:"def-detect_vector_data_type",level:2},{value:"Parameters",id:"Parameters",level:3},{value:"Returns",id:"Returns",level:3},{value:"Raises",id:"Raises",level:3},{value:"def check_array_type(...)",id:"def-check_array_type",level:2},{value:"Parameters",id:"Parameters-1",level:3},{value:"Returns",id:"Returns-1",level:3},{value:"Raises",id:"Raises-1",level:3},{value:"def check_shape_match(...)",id:"def-check_shape_match",level:2},{value:"Parameters",id:"Parameters-2",level:3},{value:"Raises",id:"Raises-2",level:3},{value:"def check_feature_dimension(...)",id:"def-check_feature_dimension",level:2},{value:"Parameters",id:"Parameters-3",level:3},{value:"Raises",id:"Raises-3",level:3},{value:"def check_binary_array(...)",id:"def-check_binary_array",level:2},{value:"Raises",id:"Raises-4",level:3}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"Validation",children:"Validation"})}),"\n",(0,a.jsx)(n.h2,{id:"def-detect_vector_data_type",children:"def detect_vector_data_type(...)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def detect_vector_data_type(\n    vector: npt.NDArray\n) -> FeatureType:\n"})}),"\n",(0,a.jsx)(n.p,{children:"Detects the type of data in a given vector."}),"\n",(0,a.jsx)(n.p,{children:"This function analyzes the input vector and classifies its data as one of the supported types:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"binary"}),": Boolean values (",(0,a.jsx)(n.code,{children:"True"}),"/",(0,a.jsx)(n.code,{children:"False"}),") or integer ",(0,a.jsx)(n.code,{children:"0"}),"/",(0,a.jsx)(n.code,{children:"1"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"continuous"}),": Float values within the normalized range ",(0,a.jsx)(n.code,{children:"[0.0, 1.0]"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"ranged"}),": Float values outside the normalized range."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"Parameters",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"vector"})," (",(0,a.jsx)(n.code,{children:"npt.NDArray"}),"): An array containing the data to be classified."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"Returns",children:"Returns"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"FeatureType"})," (",(0,a.jsx)(n.code,{children:'Literal["binary-features", "continuous-features", "ranged-features"]'}),"): The detected type of data in the vector."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"Raises",children:"Raises"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"UnsupportedDataTypeError"}),": Raised if the vector contains an unsupported data type."]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"def-check_array_type",children:"def check_array_type(...)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'def check_array_type(x, name: str = "X") -> npt.NDArray:\n'})}),"\n",(0,a.jsx)(n.p,{children:"Ensure X is a numpy array. Convert from list if needed."}),"\n",(0,a.jsx)(n.h3,{id:"Parameters-1",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"x"})," (",(0,a.jsx)(n.code,{children:"Any"}),"): Array, containing the samples and their characteristics, [",(0,a.jsx)(n.code,{children:"N samples"})," (rows)][",(0,a.jsx)(n.code,{children:"N features"})," (columns)]."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"name"})," (",(0,a.jsx)(n.code,{children:"str"}),", default='X'): Variable name used in error messages."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"Returns-1",children:"Returns"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"npt.NDArray"}),": The converted or validated array."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"Raises-1",children:"Raises"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"TypeError"}),": If X or y are not ndarrays or have incompatible shapes."]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"def-check_shape_match",children:"def check_shape_match(...)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def check_shape_match(x: npt.NDArray, y: npt.NDArray):\n"})}),"\n",(0,a.jsx)(n.p,{children:"Ensure X and y have compatible first dimensions."}),"\n",(0,a.jsx)(n.h3,{id:"Parameters-2",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"x"})," (",(0,a.jsx)(n.code,{children:"npt.NDArray"}),"): Array, containing the samples and their characteristics, [",(0,a.jsx)(n.code,{children:"N samples"})," (rows)][",(0,a.jsx)(n.code,{children:"N features"})," (columns)]."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"y"})," (",(0,a.jsx)(n.code,{children:"npt.NDArray"}),"): Array of target classes of ",(0,a.jsx)(n.code,{children:"x"})," with [",(0,a.jsx)(n.code,{children:"N samples"})," (lines)]."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"Raises-2",children:"Raises"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"TypeError"}),": If x or y are not ndarrays or have incompatible shapes."]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"def-check_feature_dimension",children:"def check_feature_dimension(...)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def check_feature_dimension(x: npt.NDArray, expected: int):\n"})}),"\n",(0,a.jsx)(n.p,{children:"Ensure X has the expected number of features."}),"\n",(0,a.jsx)(n.h3,{id:"Parameters-3",children:"Parameters"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"x"})," (",(0,a.jsx)(n.code,{children:"npt.NDArray"}),"): Input array for prediction, containing the samples and their characteristics, [",(0,a.jsx)(n.code,{children:"N samples"})," (rows)][",(0,a.jsx)(n.code,{children:"N features"})," (columns)]."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"expected"})," (",(0,a.jsx)(n.code,{children:"int"}),"): Expected number of features per sample (columns in X)."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"Raises-3",children:"Raises"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"FeatureDimensionMismatch"}),": If the number of features in X does not match the expected number."]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"def-check_binary_array",children:"def check_binary_array(...)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"def check_binary_array(x: npt.NDArray):\n"})}),"\n",(0,a.jsx)(n.p,{children:"Ensure X contains only 0 and 1."}),"\n",(0,a.jsx)(n.h3,{id:"Raises-4",children:"Raises"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ValueError"}),": If feature_type is binary-features and X contains values that are not composed only of 0 and 1."]}),"\n"]})]})}function o(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>c});var r=s(6540);const a={},i=r.createContext(a);function d(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:d(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);