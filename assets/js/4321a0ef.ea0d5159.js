"use strict";(self.webpackChunkais_package_github_io=self.webpackChunkais_package_github_io||[]).push([[2957],{6497:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"aisp-techniques/clonal-selection-algorithms/clonalg","title":"CLONALG - Clonal Selection Algorithm","description":"The Clonalg class is an optimization algorithm inspired by the biological process of clonal selection in the immune system. This implementation is designed for minimizing or maximizing cost functions in various problem types, including binary, continuous, ranged-value, and permutation problems.","source":"@site/versioned_docs/version-0.4.x/aisp-techniques/clonal-selection-algorithms/clonalg.md","sourceDirName":"aisp-techniques/clonal-selection-algorithms","slug":"/aisp-techniques/clonal-selection-algorithms/clonalg","permalink":"/docs/aisp-techniques/clonal-selection-algorithms/clonalg","draft":false,"unlisted":false,"tags":[],"version":"0.4.x","lastUpdatedBy":"Jo\xe3o Paulo","lastUpdatedAt":1758596852000,"frontMatter":{"id":"clonalg","sidebar_label":"CLONALG - Clonal Selection Algorithm","keywords":["CLONALG","clonal selection algorithm","optimization","binary optimization","real-valued optimization","ranged-value problems","permutation problems","metaheuristics","bio-inspired algorithms","machine learning optimization"],"lastUpdatedAt":"2025/09/21","author":"Jo\xe3o Paulo"},"sidebar":"docs","previous":{"title":"ABR - Artificial Recognition Ball","permalink":"/docs/aisp-techniques/clonal-selection-algorithms/airs/abr"},"next":{"title":"Immune Network Theory","permalink":"/docs/aisp-techniques/immune-network-theory/"}}');var o=i(4848),s=i(8453);const l={id:"clonalg",sidebar_label:"CLONALG - Clonal Selection Algorithm",keywords:["CLONALG","clonal selection algorithm","optimization","binary optimization","real-valued optimization","ranged-value problems","permutation problems","metaheuristics","bio-inspired algorithms","machine learning optimization"],lastUpdatedAt:"2025/09/21",author:"Jo\xe3o Paulo"},r="CLONALG - Clonal Selection Algorithm",c={},a=[{value:"CLONALG Constructor",id:"clonalg-constructor",level:2},{value:"Public Methods",id:"public-methods",level:2},{value:"Function <code>optimize(...)</code>",id:"function-optimize",level:3},{value:"Function <code>affinity_function(...)</code>",id:"function-affinity_function",level:3},{value:"Private Methods",id:"private-methods",level:2},{value:"Function <code>_select_top_antibodies(...)</code>",id:"function-_select_top_antibodies",level:3},{value:"Function <code>_init_population_antibodies(...)</code>",id:"function-_init_population_antibodies",level:3},{value:"Function <code>_diversity_introduction(...)</code>",id:"function-_diversity_introduction",level:3},{value:"Function <code>_clone_and_mutate(...)</code>",id:"function-_clone_and_mutate",level:3},{value:"Function <code>_clone_and_hypermutation(...)</code>",id:"function-_clone_and_hypermutation",level:3},{value:"1",id:"1",level:5}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h5:"h5",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"clonalg---clonal-selection-algorithm",children:"CLONALG - Clonal Selection Algorithm"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Clonalg"})," class is an ",(0,o.jsx)(n.strong,{children:"optimization algorithm"})," inspired by the biological process of clonal selection in the immune system. This implementation is designed for minimizing or maximizing cost functions in various problem types, including binary, continuous, ranged-value, and permutation problems."]}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["The CLONALG implementation was inspired by the description presented in ",(0,o.jsx)(n.a,{href:"#1",children:"1"}),"."]})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:"This CLONALG implementation contains some changes based on the AISP context, for general\napplication to various problems, which may produce results different from the standard or\nspecific implementation. This adaptation aims to generalize CLONALG to minimization and\nmaximization tasks, in addition to supporting continuous, discrete, and permutation problems."})}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"clonalg-constructor",children:"CLONALG Constructor"}),"\n",(0,o.jsx)(n.p,{children:"The constructor initializes the CLONALG instance with key parameters that define the optimization process."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"problem_size"}),": ",(0,o.jsx)(n.code,{children:"int"})," - The dimension of the problem to be optimized."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"N"}),": ",(0,o.jsx)(n.code,{children:"int"}),", default=50 - The number of memory cells (antibodies) in the population."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"rate_clonal"}),": ",(0,o.jsx)(n.code,{children:"float"}),", default=10 - The maximum number of possible clones of a cell. This value is multiplied by the cell's affinity to determine the number of clones."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"rate_hypermutation"}),": ",(0,o.jsx)(n.code,{children:"float"}),", default=0.75 - The rate of mutated clones, used as a scalar factor."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"n_diversity_injection"}),": ",(0,o.jsx)(n.code,{children:"int"}),", default=5 - The number of new random memory cells injected to maintain diversity."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"selection_size"}),": ",(0,o.jsx)(n.code,{children:"int"}),", default=5 - The number of best antibodies selected for cloning."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"affinity_function"}),": ",(0,o.jsx)(n.code,{children:"Optional[Callable[..., npt.NDArray]]"}),", default=None - The objective function used to evaluate candidate solutions."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"feature_type"}),": ",(0,o.jsx)(n.code,{children:"FeatureTypeAll"}),", default='ranged-features' - The type of problem samples, which can be ",(0,o.jsx)(n.code,{children:"'continuous-features'"}),", ",(0,o.jsx)(n.code,{children:"'binary-features'"}),", ",(0,o.jsx)(n.code,{children:"'ranged-features'"}),", or ",(0,o.jsx)(n.code,{children:"'permutation-features'"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"bounds"}),": ",(0,o.jsx)(n.code,{children:"Optional[Dict]"}),", default=None - A dictionary defining the search limits for ",(0,o.jsx)(n.code,{children:"'ranged-features'"})," problems. Can be a single fixed range or a list of ranges for each dimension."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"mode"}),": ",(0,o.jsx)(n.code,{children:'Literal["min", "max"]'}),', default="min" - Specifies whether the algorithm minimizes or maximizes the cost function.']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"seed"}),": ",(0,o.jsx)(n.code,{children:"Optional[int]"}),", default=None - A seed for random number generation."]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"public-methods",children:"Public Methods"}),"\n",(0,o.jsxs)(n.h3,{id:"function-optimize",children:["Function ",(0,o.jsx)(n.code,{children:"optimize(...)"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"def optimize(\n    self,\n    max_iters: int = 50,\n    n_iter_no_change=10, \n    verbose: bool = True\n) -> npt.NDArray:\n"})}),"\n",(0,o.jsx)(n.p,{children:"This method execute the optimization process and return the population."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Input parameters:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"max_iters"}),": ",(0,o.jsx)(n.code,{children:"int"}),", default=50 - The maximum number of interactions."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"n_iter_no_change"}),": ",(0,o.jsx)(n.code,{children:"int"}),", default=10 - The maximum number of iterations without an improvement in the best solution."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"verbose"}),": ",(0,o.jsx)(n.code,{children:"bool"}),", default=True - A flag to enable or disable detailed output during the optimization process."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"npt.NDArray"}),": The best antibody population after clonal expansion."]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.h3,{id:"function-affinity_function",children:["Function ",(0,o.jsx)(n.code,{children:"affinity_function(...)"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"def affinity_function(self, solution: npt.NDArray) -> np.float64:\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This method evaluates the affinity of a candidate solution. It raises a ",(0,o.jsx)(n.code,{children:"NotImplementedError"})," if no affinity function has been provided to the class instance."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Input parameters:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"solution"}),": ",(0,o.jsx)(n.code,{children:"npt.NDArray"})," - The candidate solution to be evaluated."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"np.float64"}),": The affinity value associated with the solution."]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h2,{id:"private-methods",children:"Private Methods"}),"\n",(0,o.jsxs)(n.h3,{id:"function-_select_top_antibodies",children:["Function ",(0,o.jsx)(n.code,{children:"_select_top_antibodies(...)"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"def _select_top_antibodies(self, n: int, antibodies: list[tuple]) -> list[tuple]:\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This method selects the top ",(0,o.jsx)(n.code,{children:"n"})," antibodies based on their affinity scores, according to the ",(0,o.jsx)(n.code,{children:"mode"})," (",(0,o.jsx)(n.code,{children:"'min'"})," or ",(0,o.jsx)(n.code,{children:"'max'"}),")."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Input parameters:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"n"}),": ",(0,o.jsx)(n.code,{children:"int"})," - The number of antibodies to select."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"antibodies"}),": ",(0,o.jsx)(n.code,{children:"list[tuple]"})," - A list of tuples, where each tuple represents an antibody and its associated score."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"list[tuple]"}),": A list containing the ",(0,o.jsx)(n.code,{children:"n"})," selected antibodies."]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.h3,{id:"function-_init_population_antibodies",children:["Function ",(0,o.jsx)(n.code,{children:"_init_population_antibodies(...)"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"def _init_population_antibodies(self) -> npt.NDArray:\n"})}),"\n",(0,o.jsx)(n.p,{children:"This method initializes the initial population of antibodies randomly."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"npt.NDArray"}),": A list of the initialized antibodies."]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.h3,{id:"function-_diversity_introduction",children:["Function ",(0,o.jsx)(n.code,{children:"_diversity_introduction(...)"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"def _diversity_introduction(self):\n"})}),"\n",(0,o.jsx)(n.p,{children:"This method introduces new random antibodies into the population to maintain genetic diversity and help prevent premature convergence."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"npt.NDArray"}),": An array of new random antibodies."]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.h3,{id:"function-_clone_and_mutate",children:["Function ",(0,o.jsx)(n.code,{children:"_clone_and_mutate(...)"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"def _clone_and_mutate(self, antibody: npt.NDArray, n_clone: int, rate_hypermutation: float) -> npt.NDArray:\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This method generates mutated clones from a single antibody. The mutation strategy depends on the ",(0,o.jsx)(n.code,{children:"feature_type"})," specified during initialization (",(0,o.jsx)(n.code,{children:"'binary-features'"}),", ",(0,o.jsx)(n.code,{children:"'continuous-features'"}),", ",(0,o.jsx)(n.code,{children:"'ranged-features'"}),", or ",(0,o.jsx)(n.code,{children:"'permutation-features'"}),")."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Input parameters:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"antibody"}),": ",(0,o.jsx)(n.code,{children:"npt.NDArray"})," - The original antibody vector to be cloned and mutated."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"n_clone"}),": ",(0,o.jsx)(n.code,{children:"int"})," - The number of clones to generate."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"rate_hypermutation"}),": ",(0,o.jsx)(n.code,{children:"float"})," - The hypermutation rate."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"npt.NDArray"}),": An array containing the mutated clones."]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.h3,{id:"function-_clone_and_hypermutation",children:["Function ",(0,o.jsx)(n.code,{children:"_clone_and_hypermutation(...)"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"def _clone_and_hypermutation(self, population: list[tuple]) -> list:\n"})}),"\n",(0,o.jsx)(n.p,{children:"This method clones and hypermutates a population of antibodies. It returns a list of all clones and their affinities with respect to the cost function."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Input parameters:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"population"}),": ",(0,o.jsx)(n.code,{children:"list[tuple]"})," - The list of antibodies to be evaluated and cloned."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"list"}),": A list of mutated clones."]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsx)(n.h1,{id:"references",children:"References"}),"\n",(0,o.jsx)(n.h5,{id:"1",children:"1"}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["BROWNLEE, Jason. Clonal Selection Algorithm. Clever Algorithms: Nature-inspired Programming Recipes., 2011. Available at: ",(0,o.jsx)(n.a,{href:"https://cleveralgorithms.com/nature-inspired/immune/clonal_selection_algorithm.html",children:"https://cleveralgorithms.com/nature-inspired/immune/clonal_selection_algorithm.html"})]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var t=i(6540);const o={},s=t.createContext(o);function l(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);