"use strict";(self.webpackChunkais_project_github_io=self.webpackChunkais_project_github_io||[]).push([[620],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(n),m=i,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(h,l(l({ref:t},c),{},{components:n})):a.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[d]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8769:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={id:"rnsa",title:"RNSA",sidebar_label:"RNSA - Real-Valued Negative Selection Algorithm",sidebar_position:1,keywords:["Real-Valued","classifying","anomalies","not self","V-detector"]},l="RNSA (Real-Valued Negative Selection Algorithm)",o={unversionedId:"aisp-techniques/Negative Selection/rnsa",id:"aisp-techniques/Negative Selection/rnsa",title:"RNSA",description:"Constructor RNSA:",source:"@site/docs/aisp-techniques/Negative Selection/RNSA.md",sourceDirName:"aisp-techniques/Negative Selection",slug:"/aisp-techniques/Negative Selection/rnsa",permalink:"/docs/aisp-techniques/Negative Selection/rnsa",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"rnsa",title:"RNSA",sidebar_label:"RNSA - Real-Valued Negative Selection Algorithm",sidebar_position:1,keywords:["Real-Valued","classifying","anomalies","not self","V-detector"]},sidebar:"tutorialSidebar",previous:{title:"Negative selection",permalink:"/docs/aisp-techniques/Negative Selection/"},next:{title:"BNSA - Binary Negative Selection Algorithm",permalink:"/docs/aisp-techniques/Negative Selection/bnsa"}},s={},p=[{value:"Constructor RNSA:",id:"constructor-rnsa",level:2},{value:"Fuction fit(...)",id:"fuction-fit",level:3},{value:"Fuction predict(...)",id:"fuction-predict",level:3},{value:"Function score(...):",id:"function-score",level:3},{value:"Private Methods",id:"private-methods",level:2},{value:"Fuction __checks_valid_detector(...):",id:"fuction-__checks_valid_detector",level:3},{value:"Fuction __compare_KnearestNeighbors_List(...):",id:"fuction-__compare_knearestneighbors_list",level:3},{value:"Function __compare_sample_to_detectors(...):",id:"function-__compare_sample_to_detectors",level:3},{value:"Function __detector_is_valid_to_Vdetector(...):",id:"function-__detector_is_valid_to_vdetector",level:3},{value:"Fuction __distance(...):",id:"fuction-__distance",level:3},{value:"Function __slice_index_list_by_class(...):",id:"function-__slice_index_list_by_class",level:3}],c={toc:p},d="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"rnsa-real-valued-negative-selection-algorithm"},"RNSA (Real-Valued Negative Selection Algorithm)"),(0,i.kt)("h2",{id:"constructor-rnsa"},"Constructor RNSA:"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"RNSA")," (Real-Valued Negative Selection Algorithm) class has the purpose of classifying and identifying anomalies through the self and not self methods."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"RNSA(self, N: int = 100, r: float = 0.05, r_s: float = 0.0001, k: int = 1, metric: str = 'euclidean', seed: int = None, max_discards:int = 100, algorithm: str = 'default-NSA', cell_bounds: bool = False):\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Attributes:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"N")," (",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"): Number of detectors. Defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"100"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"r")," (",(0,i.kt)("inlineCode",{parentName:"p"},"float"),"): Radius of the detector. Defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.05"),"."),(0,i.kt)("admonition",{parentName:"li",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"it is important to consider that setting a very low radius for the detector can significantly reduce the detection rate. On the other hand, a very large radius can make it impossible to incorporate the detector into the search space, which can also compromise detection performance. It is essential to find a balance between the radius size and detection efficiency to achieve the best possible results."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"k")," (",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"): Number of neighbors near the randomly generated detectors to perform the distance average calculation. Defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"metric")," (",(0,i.kt)("inlineCode",{parentName:"p"},"str"),"): Way to calculate the distance between the detector and the sample:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"'Euclidean'")," \u279c The calculation of the distance is given by the expression: \u221a( (X\u2081 \u2013 X\u2082)\xb2 + (Y\u2081 \u2013 Y\u2082)\xb2 + ... + (Yn \u2013 Yn)\xb2).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"'minkowski'")," \u279c The calculation of the distance is given by the expression: ( |X\u2081 \u2013 Y\u2081|p + |X\u2082 \u2013 Y\u2082|p + ... |Xn \u2013 Yn|p) \xb9/\u209a , In this project ",(0,i.kt)("inlineCode",{parentName:"p"},"p == 2"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"'manhattan'")," \u279c The calculation of the distance is given by the expression: ( |X\u2081 \u2013 X\u2082| + |Y\u2081 \u2013 Y\u2082| + ...+ |Yn \u2013 Yn\u2082|) ."),(0,i.kt)("p",{parentName:"li"},"Defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"'euclidean'"),"."))))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"max_discards")," (",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"): This parameter indicates the maximum number of consecutive detector discards, aimed at preventing a possible infinite loop in case a radius is defined that cannot generate non-self detectors.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"seed")," (",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"): Seed for the random generation of values in the detectors. Defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"algorithm")," (",(0,i.kt)("inlineCode",{parentName:"p"},"str"),"), Set the algorithm version:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"'default-NSA'"),": Default algorithm with fixed radius.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"'V-detector'"),': This algorithm is based on the article "',(0,i.kt)("a",{parentName:"p",href:"https://doi.org/10.1007/978-3-540-24854-5_30"},"Real-Valued Negative Selection Algorithm with Variable-Sized Detectors"),'", by Ji, Z., Dasgupta, D. (2004), and uses a variable radius for anomaly detection in feature spaces.'),(0,i.kt)("p",{parentName:"li"},"Defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"'default-NSA'"),".")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"r_s")," (",(0,i.kt)("inlineCode",{parentName:"p"},"float"),"): r\u209b Radius of the ",(0,i.kt)("inlineCode",{parentName:"p"},"X")," own samples.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"cell_bounds")," (",(0,i.kt)("inlineCode",{parentName:"p"},"bool"),"): If set to ",(0,i.kt)("inlineCode",{parentName:"p"},"True"),", this option limits the generation of detectors to the space within the plane between 0 and 1.\nThis means that any detector whose radius exceeds this limit is discarded, this variable is only used in the ",(0,i.kt)("inlineCode",{parentName:"p"},"V-detector")," algorithm."))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Other variables initiated:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"detectors")," (",(0,i.kt)("inlineCode",{parentName:"p"},"dict"),"): This variable stores a list of detectors by class.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"classes")," (",(0,i.kt)("inlineCode",{parentName:"p"},"npt.NDArray"),"): list of output classes."))),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"fuction-fit"},"Fuction fit(...)"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"fit(...)")," function generates the detectors for non-fits with respect to the samples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def fit(self, X: npt.NDArray, y: npt.NDArray):\n")),(0,i.kt)("p",null,"In it, training is performed according to ",(0,i.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),", using the negative selection method(",(0,i.kt)("inlineCode",{parentName:"p"},"NegativeSelect"),")."),(0,i.kt)("p",null,"The input parameters are: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"X"),": array with the characteristics of the samples with ",(0,i.kt)("strong",{parentName:"p"},"N")," samples (rows) and ",(0,i.kt)("strong",{parentName:"p"},"N")," characteristics (columns). ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"y"),": array with the output classes arranged in ",(0,i.kt)("strong",{parentName:"p"},"N")," samples that are related to ",(0,i.kt)("inlineCode",{parentName:"p"},"X"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"verbose"),": boolean with default value ",(0,i.kt)("inlineCode",{parentName:"p"},"True"),", determines if the feedback from the detector generation will be printed."))),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Returns the instance of the class.")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"fuction-predict"},"Fuction predict(...)"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"predict(...)")," function performs class prediction using the generated detectors:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def predict(self, X: npt.NDArray) -> npt.NDArray:\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The input parameter is:")," "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"X"),": array with the characteristics for the prediction, with ",(0,i.kt)("strong",{parentName:"li"},"N")," samples (Rows) and ",(0,i.kt)("strong",{parentName:"li"},"N")," columns.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns:")," "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"C"),": prediction array, with the output classes for the given characteristics."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"None"),": if there are no detectors.")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"function-score"},"Function score(...):"),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"score(...)")," calculates the accuracy of the trained model by making predictions and computing accuracy."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def score(self, X: npt.NDArray, y: list) -> float:\n")),(0,i.kt)("p",null,"It returns the accuracy as a float type."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"private-methods"},"Private Methods"),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"fuction-__checks_valid_detector"},"Fuction __checks_valid_detector(...):"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"def __checks_valid_detector(...)")," function checks if the detector has a valid ",(0,i.kt)("inlineCode",{parentName:"p"},"r")," radius for the non-self of the class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def __checks_valid_detector(self, X: npt.NDArray, vector_x: npt.NDArray, samplesIndexClass: npt.NDArray) -> bool:\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The input parameters are:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"X"),": array with sample characteristics with ",(0,i.kt)("strong",{parentName:"p"},"N")," samples (rows) and ",(0,i.kt)("strong",{parentName:"p"},"N")," characteristics (columns), normalized to values between ","[0, 1]",".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"vector_x"),": Randomly generated candidate detector.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"samplesIndexClass"),": Array with the indexes of a class."))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"True")," for detectors that do not have samples inside or ",(0,i.kt)("inlineCode",{parentName:"p"},"False")," if they do."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"fuction-__compare_knearestneighbors_list"},"Fuction __compare_KnearestNeighbors_List(...):"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"def __compare_KnearestNeighbors_List(...)")," function compares the distance of the k-nearest neighbors, so if the distance of the new sample is smaller, replaces ",(0,i.kt)("inlineCode",{parentName:"p"},"k-1")," and sorts in ascending order:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def __compare_KnearestNeighbors_List(self, knn: npt.NDArray, distance: float) -> npt.NDArray:\n")),(0,i.kt)("p",null,"Returns a list of k-nearest neighbor distances."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"function-__compare_sample_to_detectors"},"Function __compare_sample_to_detectors(...):"),(0,i.kt)("p",null,"Function to compare a sample with the detectors, verifying if the sample is proper.\nIn this function, when there is class ambiguity, it returns the class that has the greatest average distance between the detectors."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def __compare_sample_to_detectors(self, line):\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The input parameters are:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"line: vector with N-features")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns:")," The predicted class with the detectors or None if the sample does not qualify for any class."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"function-__detector_is_valid_to_vdetector"},"Function __detector_is_valid_to_Vdetector(...):"),(0,i.kt)("p",null,"Check if the distance between the detector and the samples, minus the radius of the samples, is greater than the minimum radius."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def __detector_is_valid_to_Vdetector(self, distance, vector_x):\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The input parameters are:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"distance (",(0,i.kt)("inlineCode",{parentName:"li"},"float"),"): minimum distance calculated between all samples."),(0,i.kt)("li",{parentName:"ul"},"vector_x (",(0,i.kt)("inlineCode",{parentName:"li"},"numpy.ndarray"),"): randomly generated candidate detector vector x with values between 0 and 1.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns:")," "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"False"),": if the calculated radius is smaller than the minimum distance or exceeds the edge of the space, if this option is enabled."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"True")," and the distance minus the radius of the samples, if the radius is valid.`")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"fuction-__distance"},"Fuction __distance(...):"),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"def __distance(...)")," calculates the distance between two points using the technique defined in ",(0,i.kt)("inlineCode",{parentName:"p"},"metric"),", which are: ",(0,i.kt)("inlineCode",{parentName:"p"},"'euclidean', 'norm_euclidean', or 'manhattan'")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def __distance(self, u: npt.NDArray, v: npt.NDArray):\n")),(0,i.kt)("p",null,"The input parameters are ",(0,i.kt)("inlineCode",{parentName:"p"},"u")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," NDArrays, with the coordinates for the points."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns:")," the distance (",(0,i.kt)("inlineCode",{parentName:"p"},"double"),") between the two points."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"function-__slice_index_list_by_class"},"Function __slice_index_list_by_class(...):"),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"__slice_index_list_by_class(...)"),", separates the indices of the lines according to the output class, to go through the sample array, only in the positions that the output is the class that is being trained:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def __slice_index_list_by_class(self, y: npt.NDArray) -> dict:\n")),(0,i.kt)("p",null,"Returns a dictionary with the classes as key and the indices in ",(0,i.kt)("inlineCode",{parentName:"p"},"X")," of the samples."),(0,i.kt)("hr",null))}u.isMDXComponent=!0}}]);