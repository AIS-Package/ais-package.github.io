"use strict";(self.webpackChunkais_package_github_io=self.webpackChunkais_package_github_io||[]).push([[8644],{5409:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"advanced-guides/Base Classes Reference/nsa","title":"Negative Selection Base","description":"`class BaseNSA(BaseClassifier, ABC)`","source":"@site/versioned_docs/version-0.3.x/advanced-guides/Base Classes Reference/nsa.md","sourceDirName":"advanced-guides/Base Classes Reference","slug":"/advanced-guides/Base Classes Reference/nsa","permalink":"/docs/advanced-guides/Base Classes Reference/nsa","draft":false,"unlisted":false,"tags":[],"version":"0.3.x","lastUpdatedBy":"Jo\xe3o Paulo","lastUpdatedAt":1755917992000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Negative Selection Base","sidebar_label":"Negative Selection","lastUpdatedAt":"2025/04/04","author":"Jo\xe3o Paulo","keywords":["BaseNSA","Negative Selection","Artificial Immune Systems","RNSA","BNSA","Base Classifier","Machine Learning","Anomaly Detection","Continuous Features","Binary Features","Feature Validation","Classification"]},"sidebar":"docs","previous":{"title":"Mutation","permalink":"/docs/advanced-guides/Base module/Mutation"},"next":{"title":"Clonal Selection Algorithms","permalink":"/docs/category/clonal-selection-algorithms"}}');var r=s(4848),t=s(8453);const c={sidebar_position:1,title:"Negative Selection Base",sidebar_label:"Negative Selection",lastUpdatedAt:"2025/04/04",author:"Jo\xe3o Paulo",keywords:["BaseNSA","Negative Selection","Artificial Immune Systems","RNSA","BNSA","Base Classifier","Machine Learning","Anomaly Detection","Continuous Features","Binary Features","Feature Validation","Classification"]},a=void 0,o={},l=[{value:"<code>class BaseNSA(BaseClassifier, ABC)</code>",id:"class-basensabaseclassifier-abc",level:2},{value:"Protected Functions:",id:"protected-functions",level:3},{value:"Function _check_and_raise_exceptions_fit(...):",id:"function-_check_and_raise_exceptions_fit",level:4},{value:"Function _check_and_raise_exceptions_predict(...):",id:"function-_check_and_raise_exceptions_predict",level:4},{value:"Detector class",id:"detector-class",level:2}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"class-basensabaseclassifier-abc",children:(0,r.jsx)(n.code,{children:"class BaseNSA(BaseClassifier, ABC)"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"BaseNSA"})," class contains utility functions with the ",(0,r.jsx)(n.code,{children:"protected"})," modifier that can be inherited by various classes for ease of use. It includes functions for distance calculation, data separation to improve training and prediction efficiency, accuracy measurement and other functions."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h3,{id:"protected-functions",children:"Protected Functions:"}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"function-_check_and_raise_exceptions_fit",children:"Function _check_and_raise_exceptions_fit(...):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def _check_and_raise_exceptions_fit(\n    X: npt.NDArray = None,\n    y: npt.NDArray = None,\n    _class_: Literal["RNSA", "BNSA"] = "RNSA",\n) -> None:\n'})}),"\n",(0,r.jsx)(n.p,{children:"Function responsible for verifying fit function parameters and throwing exceptions if the verification is not successful."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"X"})})," (",(0,r.jsx)(n.code,{children:"npt.NDArray"}),"): Training array, containing the samples and their characteristics, [",(0,r.jsx)(n.code,{children:"N samples"})," (rows)][",(0,r.jsx)(n.code,{children:"N features"})," (columns)]."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"y"})})," (",(0,r.jsx)(n.code,{children:"npt.NDArray"}),"): Array of target classes of ",(0,r.jsx)(n.code,{children:"X"})," with [",(0,r.jsx)(n.code,{children:"N samples"})," (lines)]."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.em,{children:"class"})})})," (Literal[RNSA, BNSA], optional): Current class. Defaults to 'RNSA'."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Raises"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"TypeError"}),": If X or y are not ndarrays or have incompatible shapes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ValueError"}),": If ",(0,r.jsx)(n.em,{children:"class"})," is BNSA and X contains values that are not composed only of 0 and 1."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h4,{id:"function-_check_and_raise_exceptions_predict",children:"Function _check_and_raise_exceptions_predict(...):"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def _check_and_raise_exceptions_predict(\n    X: npt.NDArray = None,\n    expected: int = 0,\n    _class_: Literal["RNSA", "BNSA"] = "RNSA",\n) -> None:\n'})}),"\n",(0,r.jsx)(n.p,{children:"Function responsible for verifying predict function parameters and throwing exceptions if the verification is not successful."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"X"})})," (",(0,r.jsx)(n.code,{children:"npt.NDArray"}),"): Input array for prediction, containing the samples and their characteristics, [",(0,r.jsx)(n.code,{children:"N samples"})," (rows)][",(0,r.jsx)(n.code,{children:"N features"})," (columns)]."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"expected"})})," (",(0,r.jsx)(n.code,{children:"int"}),"): Expected number of features per sample (columns in X)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:"class"})," (",(0,r.jsx)(n.code,{children:"Literal[RNSA, BNSA], optional"}),"): Current class. Defaults to 'RNSA'."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Raises"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"TypeError"}),": If X is not an ndarray or list."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"FeatureDimensionMismatch"}),": If the number of features in X does not match the expected number."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"ValueError"}),": If ",(0,r.jsx)(n.em,{children:"class"})," is BNSA and X contains values that are not composed only of 0 and 1."]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"detector-class",children:"Detector class"}),"\n",(0,r.jsx)(n.p,{children:"Represents a non-self detector of the RNSA class."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"position"})})," (",(0,r.jsx)(n.code,{children:"np.ndarray"}),"): Detector feature vector."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.em,{children:(0,r.jsx)(n.strong,{children:"radius"})})," (",(0,r.jsx)(n.code,{children:"float, optional"}),"): Detector radius, used in the V-detector algorithm."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>a});var i=s(6540);const r={},t=i.createContext(r);function c(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);