"use strict";(self.webpackChunkais_package_github_io=self.webpackChunkais_package_github_io||[]).push([[9804],{486:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"aisp-techniques/Negative Selection/bnsa","title":"BNSA","description":"Constructor RNSA:","source":"@site/versioned_docs/version-0.1.x/aisp-techniques/Negative Selection/BNSA.md","sourceDirName":"aisp-techniques/Negative Selection","slug":"/aisp-techniques/Negative Selection/bnsa","permalink":"/docs/0.1.x/aisp-techniques/Negative Selection/bnsa","draft":false,"unlisted":false,"tags":[],"version":"0.1.x","lastUpdatedBy":"Jo\xe3o Paulo","lastUpdatedAt":1747440000000,"sidebarPosition":2,"frontMatter":{"id":"bnsa","title":"BNSA","sidebar_label":"BNSA - Binary Negative Selection Algorithm","sidebar_position":2,"pagination_next":null,"keywords":["Binary","classifying","anomalies","not self","affinity threshold","Negative Selection Algorithm","Artificial Immune System (AIS)","Self and non-self","Immune","Computa\xe7\xe3o Natural","Real-Valued","V-detector"],"last_update":{"date":"2025/05/17","author":"Jo\xe3o Paulo"}},"sidebar":"docs","previous":{"title":"RNSA - Real-Valued Negative Selection Algorithm","permalink":"/docs/0.1.x/aisp-techniques/Negative Selection/rnsa"}}');var t=s(4848),r=s(8453);const l={id:"bnsa",title:"BNSA",sidebar_label:"BNSA - Binary Negative Selection Algorithm",sidebar_position:2,pagination_next:null,keywords:["Binary","classifying","anomalies","not self","affinity threshold","Negative Selection Algorithm","Artificial Immune System (AIS)","Self and non-self","Immune","Computa\xe7\xe3o Natural","Real-Valued","V-detector"],last_update:{date:"2025/05/17",author:"Jo\xe3o Paulo"}},c="BNSA (Binary Negative Selection Algorithm)",a={},o=[{value:"Constructor RNSA:",id:"constructor-rnsa",level:2},{value:"Function fit(...)",id:"function-fit",level:3},{value:"Function predict(...)",id:"function-predict",level:3},{value:"Function score(...)",id:"function-score",level:3},{value:"Private Methods",id:"private-methods",level:2},{value:"Function __assign_class_to_non_self_sample(...)",id:"function-__assign_class_to_non_self_sample",level:3}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"bnsa-binary-negative-selection-algorithm",children:"BNSA (Binary Negative Selection Algorithm)"})}),"\n",(0,t.jsx)(n.h2,{id:"constructor-rnsa",children:"Constructor RNSA:"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"BNSA"})," (Binary Negative Selection Algorithm) class has the purpose of classifying and identifying anomalies through the self and not self methods."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'class BNSA(\n    self,\n    N: int = 100,\n    aff_thresh: float = 0.1,\n    max_discards: int = 1000,\n    seed: int = None,\n    no_label_sample_selection: Literal[\n        "max_average_difference", "max_nearest_difference"\n    ] = "max_average_difference",\n)\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Attributes:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"N"})," (",(0,t.jsx)(n.code,{children:"int"}),"): Number of detectors. Defaults to ",(0,t.jsx)(n.code,{children:"100"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"aff_thresh"})," (",(0,t.jsx)(n.code,{children:"float"}),"): The variable ('affinity threshold') represents the percentage of dissimilarity between the T cell and the own samples. The default value is 10% (0.1), while a value of 1.0 represents 100% dissimilarity."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"Setting the difference percentage too high can result in the inability to generate detectors for non-self."})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"max_discards"})," (",(0,t.jsx)(n.code,{children:"int"}),"): This parameter indicates the maximum number of detector discards in sequence, which aims to avoid a\npossible infinite loop if a radius is defined that it is not possible to generate non-self detectors. Defaults to ",(0,t.jsx)(n.code,{children:"1000"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"seed"})," (",(0,t.jsx)(n.code,{children:"int"}),"): Seed for the random generation of values in the detectors. Defaults to ",(0,t.jsx)(n.code,{children:"None"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["no_label_sample_selection (",(0,t.jsx)(n.code,{children:"str"}),"): Method for selecting labels for samples designated as non-members by all non-member detectors. ",(0,t.jsx)(n.strong,{children:"Available method types:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["(",(0,t.jsx)(n.code,{children:"max_average_difference"}),"): Selects the class with the highest average difference among the detectors."]}),"\n",(0,t.jsxs)(n.li,{children:["(",(0,t.jsx)(n.code,{children:"max_nearest_difference"}),"): Selects the class with the highest difference between the nearest and farthest detector from the sample."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Other variables initiated:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"detectors"})," (",(0,t.jsx)(n.code,{children:"dict"}),"): This variable stores a list of detectors by class."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"classes"})," (",(0,t.jsx)(n.code,{children:"npt.NDArray"}),"): list of output classes."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"function-fit",children:"Function fit(...)"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"fit(...)"})," function generates the detectors for non-fits with respect to the samples:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def fit(self, X: npt.NDArray, y: npt.NDArray, verbose: bool = True)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In it, training is performed according to ",(0,t.jsx)(n.code,{children:"X"})," and ",(0,t.jsx)(n.code,{children:"y"}),", using the negative selection method(",(0,t.jsx)(n.code,{children:"NegativeSelect"}),")."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"The input parameters are:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"X"}),": array with the characteristics of the samples with ",(0,t.jsx)(n.strong,{children:"N"})," samples (rows) and ",(0,t.jsx)(n.strong,{children:"N"})," characteristics (columns)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"y"}),": array with the output classes arranged in ",(0,t.jsx)(n.strong,{children:"N"})," samples that are related to ",(0,t.jsx)(n.code,{children:"X"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"verbose"}),": boolean with default value ",(0,t.jsx)(n.code,{children:"True"}),", determines if the feedback from the detector generation will be printed."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:"Returns the instance of the class."})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"function-predict",children:"Function predict(...)"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"predict(...)"})," function performs class prediction using the generated detectors:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def predict(self, X: npt.NDArray) -> npt.NDArray:\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"The input parameter is:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"X"}),": array with the characteristics for the prediction, with ",(0,t.jsx)(n.strong,{children:"N"})," samples (Rows) and ",(0,t.jsx)(n.strong,{children:"N"})," columns."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"C"}),": prediction array, with the output classes for the given characteristics."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"None"}),": if there are no detectors."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"function-score",children:"Function score(...)"}),"\n",(0,t.jsxs)(n.p,{children:["The function ",(0,t.jsx)(n.code,{children:"score(...)"})," calculates the accuracy of the trained model by making predictions and computing accuracy."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def score(self, X: npt.NDArray, y: list) -> float:\n"})}),"\n",(0,t.jsx)(n.p,{children:"It returns the accuracy as a float type."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"private-methods",children:"Private Methods"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"function-__assign_class_to_non_self_sample",children:"Function __assign_class_to_non_self_sample(...)"}),"\n",(0,t.jsxs)(n.p,{children:["The function ",(0,t.jsx)(n.code,{children:"__assign_class_to_non_self_sample(...)"}),', determines the class of a sample when all detectors classify it as "non-self". Classification is performed using the ',(0,t.jsx)(n.code,{children:"max_average_difference"})," and ",(0,t.jsx)(n.code,{children:"max_nearest_difference"})," methods."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def __assign_class_to_non_self_sample(self, line: npt.NDArray, c: list):\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"The input parameter is:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"line"})})," (",(0,t.jsx)(n.code,{children:"npt.NDArray"}),"): Sample to be classified."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"c"})})," (",(0,t.jsx)(n.code,{children:"list"}),"): List of predictions to be updated with the new classification."]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>c});var i=s(6540);const t={},r=i.createContext(t);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);