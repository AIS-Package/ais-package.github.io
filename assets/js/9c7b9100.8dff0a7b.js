"use strict";(self.webpackChunkais_package_github_io=self.webpackChunkais_package_github_io||[]).push([[1614],{4925:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"advanced-guides/Core/Negative Selection","title":"Negative Selection","description":"The functions perform detector checks and utilize Numba decorators for Just-In-Time compilation","source":"@site/versioned_docs/version-0.2.x/advanced-guides/Core/Negative Selection.md","sourceDirName":"advanced-guides/Core","slug":"/advanced-guides/Core/Negative Selection","permalink":"/docs/advanced-guides/Core/Negative Selection","draft":false,"unlisted":false,"tags":[],"version":"0.2.x","lastUpdatedBy":"Jo\xe3o Paulo","lastUpdatedAt":1747440000000,"frontMatter":{"last_update":{"date":"2025/05/17","author":"Jo\xe3o Paulo"}},"sidebar":"docs","previous":{"title":"Artificial Immune Recognition System","permalink":"/docs/advanced-guides/Base Classes Reference/csa/airs"},"next":{"title":"Metrics","permalink":"/docs/advanced-guides/Utils/Metrics"}}');var i=s(4848),r=s(8453);const c={last_update:{date:"2025/05/17",author:"Jo\xe3o Paulo"}},a="Negative Selection",l={},d=[{value:"Function check_detector_bnsa_validity(...):",id:"function-check_detector_bnsa_validity",level:3},{value:"Function bnsa_class_prediction(...):",id:"function-bnsa_class_prediction",level:3},{value:"Function check_detector_rnsa_validity(...):",id:"function-check_detector_rnsa_validity",level:3}];function o(e){const n={code:"code",h1:"h1",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"negative-selection",children:"Negative Selection"})}),"\n",(0,i.jsx)(n.p,{children:"The functions perform detector checks and utilize Numba decorators for Just-In-Time compilation"}),"\n",(0,i.jsx)(n.h3,{id:"function-check_detector_bnsa_validity",children:"Function check_detector_bnsa_validity(...):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def check_detector_bnsa_validity(\n    x_class: npt.NDArray,\n    vector_x: npt.NDArray,\n    aff_thresh: float\n) -> bool:\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Checks the validity of a candidate detector (vector_x) against samples from a class (x_class) using the Hamming distance. A detector is considered INVALID if its distance to any sample in ",(0,i.jsx)(n.code,{children:"x_class"})," is less than or equal to ",(0,i.jsx)(n.code,{children:"aff_thresh"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["x_class (",(0,i.jsx)(n.code,{children:"npt.NDArray"}),"): Array containing the class samples. Expected shape: (n_samples, n_features)."]}),"\n",(0,i.jsxs)(n.li,{children:["vector_x (",(0,i.jsx)(n.code,{children:"npt.NDArray"}),"): Array representing the detector. Expected shape: (n_features,)."]}),"\n",(0,i.jsxs)(n.li,{children:["aff_thresh (",(0,i.jsx)(n.code,{children:"float"}),"): Affinity threshold."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"True if the detector is valid, False otherwise."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"function-bnsa_class_prediction",children:"Function bnsa_class_prediction(...):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def bnsa_class_prediction(\n    features: npt.NDArray,\n    class_detectors: npt.NDArray,\n    aff_thresh: float\n) -> int:\n"})}),"\n",(0,i.jsx)(n.p,{children:"Defines the class of a sample from the non-self detectors."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["features (",(0,i.jsx)(n.code,{children:"npt.NDArray"}),"): binary sample to be classified (shape: [n_features])."]}),"\n",(0,i.jsxs)(n.li,{children:["class_detectors (",(0,i.jsx)(n.code,{children:"npt.NDArray"}),"): Array containing the detectors of all classes\n(shape: [n_classes, n_detectors, n_features])."]}),"\n",(0,i.jsxs)(n.li,{children:["aff_thresh (",(0,i.jsx)(n.code,{children:"float"}),"): Affinity threshold that determines whether a detector recognizes the sample as non-self."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"int: Index of the predicted class. Returns -1 if it is non-self for all classes."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"function-check_detector_rnsa_validity",children:"Function check_detector_rnsa_validity(...):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def check_detector_rnsa_validity(\n    x_class: npt.NDArray,\n    vector_x: npt.NDArray,\n    threshold: float,\n    metric: int,\n    p: float\n) -> bool:\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Checks the validity of a candidate detector (vector_x) against samples from a class (x_class) using the Hamming distance. A detector is considered INVALID if its distance to any sample in ",(0,i.jsx)(n.code,{children:"x_class"})," is less than or equal to ",(0,i.jsx)(n.code,{children:"aff_thresh"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["x_class (",(0,i.jsx)(n.code,{children:"npt.NDArray"}),"): Array containing the class samples. Expected shape:  (n_samples, n_features)."]}),"\n",(0,i.jsxs)(n.li,{children:["vector_x (",(0,i.jsx)(n.code,{children:"npt.NDArray"}),"): Array representing the detector. Expected shape: (n_features,)."]}),"\n",(0,i.jsxs)(n.li,{children:["threshold (",(0,i.jsx)(n.code,{children:"float"}),"): threshold."]}),"\n",(0,i.jsxs)(n.li,{children:["metric (",(0,i.jsx)(n.code,{children:"int"}),"): Distance metric to be used. Available options: [0 (Euclidean), 1 (Manhattan), 2 (Minkowski)]"]}),"\n",(0,i.jsxs)(n.li,{children:["p (",(0,i.jsx)(n.code,{children:"float"}),"): Parameter for the Minkowski distance (used only if ",(0,i.jsx)(n.code,{children:"metric"}),' is "minkowski").']}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"returns"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"int: Index of the predicted class. Returns -1 if it is non-self for all classes."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>a});var t=s(6540);const i={},r=t.createContext(i);function c(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);