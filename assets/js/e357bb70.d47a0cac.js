"use strict";(self.webpackChunkais_package_github_io=self.webpackChunkais_package_github_io||[]).push([[8474],{7497:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"advanced-guides/Base module/Classifier","title":"Classification","description":"`class BaseClassifier(ABC)`:","source":"@site/versioned_docs/version-0.1.x/advanced-guides/Base module/Classifier.md","sourceDirName":"advanced-guides/Base module","slug":"/advanced-guides/Base module/Classifier","permalink":"/docs/0.1.x/advanced-guides/Base module/Classifier","draft":false,"unlisted":false,"tags":[],"version":"0.1.x","lastUpdatedBy":"Jo\xe3o Paulo","lastUpdatedAt":1750019576000,"sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Classification","sidebar_label":"BaseClassifier","lastUpdatedAt":"2025/04/04","author":"Jo\xe3o Paulo"},"sidebar":"docs","previous":{"title":"Advanced Guides","permalink":"/docs/0.1.x/category/advanced-guides"},"next":{"title":"Negative Selection","permalink":"/docs/0.1.x/advanced-guides/Base Classes Reference/nsa"}}');var a=i(4848),t=i(8453);const c={sidebar_position:1,title:"Classification",sidebar_label:"BaseClassifier",lastUpdatedAt:"2025/04/04",author:"Jo\xe3o Paulo"},r="Base class for classification algorithm.",l={},d=[{value:"<code>class BaseClassifier(ABC)</code>:",id:"class-baseclassifierabc",level:2},{value:"Abstract methods",id:"abstract-methods",level:2},{value:"def fit(...)",id:"def-fit",level:3},{value:"def predict(...)",id:"def-predict",level:3},{value:"Methods",id:"methods",level:2},{value:"def score(...)",id:"def-score",level:3},{value:"Function _slice_index_list_by_class(...)",id:"function-_slice_index_list_by_class",level:3},{value:"Function get_params(...)",id:"function-get_params",level:3}];function o(e){const s={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"base-class-for-classification-algorithm",children:"Base class for classification algorithm."})}),"\n",(0,a.jsxs)(s.h2,{id:"class-baseclassifierabc",children:[(0,a.jsx)(s.code,{children:"class BaseClassifier(ABC)"}),":"]}),"\n",(0,a.jsxs)(s.p,{children:["Base class for classification algorithms, defining the abstract methods ",(0,a.jsx)(s.code,{children:"fit"})," and ",(0,a.jsx)(s.code,{children:"predict"}),", and implementing the ",(0,a.jsx)(s.code,{children:"get_params"})," method."]}),"\n",(0,a.jsx)(s.h2,{id:"abstract-methods",children:"Abstract methods"}),"\n",(0,a.jsx)(s.h3,{id:"def-fit",children:"def fit(...)"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:"def fit(self, X: npt.NDArray, y: npt.NDArray, verbose: bool = True)\n"})}),"\n",(0,a.jsx)(s.p,{children:"Fit the model to the training data."}),"\n",(0,a.jsx)(s.p,{children:"Implementation:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.a,{href:"/docs/aisp-techniques/Negative%20Selection/rnsa#function-fit",children:"RNSA"})}),"\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.a,{href:"/docs/aisp-techniques/Negative%20Selection/bnsa#function-fit",children:"BNSA"})}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"def-predict",children:"def predict(...)"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:"def predict(self, X) -> Optional[npt.NDArray]:\n"})}),"\n",(0,a.jsx)(s.p,{children:"Performs label prediction for the given data."}),"\n",(0,a.jsx)(s.p,{children:"Implementation:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.a,{href:"/docs/aisp-techniques/Negative%20Selection/rnsa#function-predict",children:"RNSA"})}),"\n",(0,a.jsx)(s.li,{children:(0,a.jsx)(s.a,{href:"/docs/aisp-techniques/Negative%20Selection/bnsa#function-predict",children:"BNSA"})}),"\n"]}),"\n",(0,a.jsx)(s.hr,{}),"\n",(0,a.jsx)(s.h2,{id:"methods",children:"Methods"}),"\n",(0,a.jsx)(s.h3,{id:"def-score",children:"def score(...)"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:"def score(self, X: npt.NDArray, y: list) -> float\n"})}),"\n",(0,a.jsx)(s.p,{children:"Score function calculates forecast accuracy."}),"\n",(0,a.jsx)(s.p,{children:"This function performs the prediction of X and checks how many elements are equal between vector y and y_predicted.\nThis function was added for compatibility with some scikit-learn functions."}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"Parameters"}),":"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:(0,a.jsx)(s.strong,{children:"X"})}),": ",(0,a.jsx)(s.code,{children:"np.ndarray"}),"\nFeature set with shape (n_samples, n_features)."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:(0,a.jsx)(s.strong,{children:"y"})}),": ",(0,a.jsx)(s.code,{children:"np.ndarray"}),"\nTrue values with shape (n_samples,)."]}),"\n"]}),"\n",(0,a.jsxs)(s.p,{children:[(0,a.jsx)(s.strong,{children:"Returns"}),":"]}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["accuracy: ",(0,a.jsx)(s.code,{children:"float"})," The accuracy of the model."]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"function-_slice_index_list_by_class",children:"Function _slice_index_list_by_class(...)"}),"\n",(0,a.jsxs)(s.p,{children:["The function ",(0,a.jsx)(s.code,{children:"__slice_index_list_by_class(...)"}),", separates the indices of the lines according to the output class, to go through the sample array, only in the positions that the output is the class that is being trained:"]}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:"def __slice_index_list_by_class(self, y: npt.NDArray) -> dict:\n"})}),"\n",(0,a.jsxs)(s.p,{children:["Returns a dictionary with the classes as key and the indices in ",(0,a.jsx)(s.code,{children:"X"})," of the samples."]}),"\n",(0,a.jsx)(s.hr,{}),"\n",(0,a.jsx)(s.h3,{id:"function-get_params",children:"Function get_params(...)"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{className:"language-python",children:"def get_params(self, deep: bool = True) -> dict:\n"})}),"\n",(0,a.jsx)(s.p,{children:"The get_params function Returns a dictionary with the object's main parameters."}),"\n",(0,a.jsx)(s.p,{children:"This function is required to ensure compatibility with scikit-learn functions."}),"\n",(0,a.jsx)(s.hr,{})]})}function h(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},8453:(e,s,i)=>{i.d(s,{R:()=>c,x:()=>r});var n=i(6540);const a={},t=n.createContext(a);function c(e){const s=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);