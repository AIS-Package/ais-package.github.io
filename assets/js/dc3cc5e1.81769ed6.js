"use strict";(self.webpackChunkais_project_github_io=self.webpackChunkais_project_github_io||[]).push([[623],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,f=u["".concat(l,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(f,s(s({ref:t},p),{},{components:n})):a.createElement(f,s({ref:t},p))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[u]="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9267:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var a=n(7462),r=(n(7294),n(3905));const i={sidebar_position:1,title:"aisp._base Class",sidebar_label:"Class - Base.",lastUpdatedAt:"2023/06/04",author:"Jo\xe3o Paulo"},s="aisp._base Class",o={unversionedId:"advanced-guides/base",id:"advanced-guides/base",title:"aisp._base Class",description:"The `_Base class contains utility functions with the protected` modifier that can be inherited by various classes for ease of use. It includes functions for distance calculation, data separation to improve training and prediction efficiency, accuracy measurement and other functions.",source:"@site/docs/advanced-guides/base.md",sourceDirName:"advanced-guides",slug:"/advanced-guides/base",permalink:"/docs/advanced-guides/base",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"aisp._base Class",sidebar_label:"Class - Base.",lastUpdatedAt:"2023/06/04",author:"Jo\xe3o Paulo"},sidebar:"tutorialSidebar",previous:{title:"Negative Selection Algorithm",permalink:"/docs/Examples/nsa"},next:{title:"About us",permalink:"/docs/About us"}},l={},c=[{value:"Protected Functions:",id:"protected-functions",level:2},{value:"def _distance(...):",id:"def-_distance",level:3},{value:"def _slice_index_list_by_class(...)",id:"def-_slice_index_list_by_class",level:3},{value:"def _score(...)",id:"def-_score",level:3}],p={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"aisp_base-class"},"aisp._base Class"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"_Base")," class contains utility functions with the ",(0,r.kt)("inlineCode",{parentName:"p"},"protected")," modifier that can be inherited by various classes for ease of use. It includes functions for distance calculation, data separation to improve training and prediction efficiency, accuracy measurement and other functions."),(0,r.kt)("h2",{id:"protected-functions"},"Protected Functions:"),(0,r.kt)("h3",{id:"def-_distance"},"def _distance(...):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _distance(self, u: npt.NDArray, v: npt.NDArray)\n")),(0,r.kt)("p",null,"Function to calculate the distance between two points by the chosen ",(0,r.kt)("inlineCode",{parentName:"p"},"metric"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"u"))," (",(0,r.kt)("inlineCode",{parentName:"li"},"npt.NDArray"),"): Coordinates of the first point."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"v"))," (",(0,r.kt)("inlineCode",{parentName:"li"},"npt.NDArray"),"): Coordinates of the second point.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Distance (",(0,r.kt)("inlineCode",{parentName:"li"},"double"),") between the two points.")),(0,r.kt)("h3",{id:"def-_slice_index_list_by_class"},"def _slice_index_list_by_class(...)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _slice_index_list_by_class(self, y: npt.NDArray) -> dict\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("inlineCode",{parentName:"p"},"__slice_index_list_by_class(...)"),", separates the indices of the lines according to the output class, to loop through the sample array, only in positions where the output is the class being trained."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"y"))," (npt.NDArray): Receives a ",(0,r.kt)("inlineCode",{parentName:"li"},"y"),"[",(0,r.kt)("inlineCode",{parentName:"li"},"N sample"),"]"," array with the output classes of the ",(0,r.kt)("inlineCode",{parentName:"li"},"X")," sample array.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"dict: A dictionary with the list of array positions(",(0,r.kt)("inlineCode",{parentName:"li"},"y"),"), with the classes as key.")),(0,r.kt)("h3",{id:"def-_score"},"def _score(...)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def _score(self, X: npt.NDArray, y: list) -> float\n")),(0,r.kt)("p",null,"Score function calculates forecast accuracy."),(0,r.kt)("p",null,"This function performs the prediction of X and checks how many elements are equal between vector y and y_predicted.\nThis function was added for compatibility with some scikit-learn functions."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"X")),": np.ndarray\nFeature set with shape (n_samples, n_features)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},(0,r.kt)("em",{parentName:"strong"},"y")),": np.ndarray\nTrue values with shape (n_samples,).")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Returns"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"accuracy: float\nThe accuracy of the model.")))}d.isMDXComponent=!0}}]);