"use strict";(self.webpackChunkais_package_github_io=self.webpackChunkais_package_github_io||[]).push([[4545],{166:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"advanced-guides/base-module/Clusterer","title":"Base class for clustering algorithm.","description":"`BaseClusterer(ABC, Base)`","source":"@site/versioned_docs/version-0.4.x/advanced-guides/base-module/Clusterer.md","sourceDirName":"advanced-guides/base-module","slug":"/advanced-guides/base-module/Clusterer","permalink":"/docs/advanced-guides/base-module/Clusterer","draft":false,"unlisted":false,"tags":[],"version":"0.4.x","lastUpdatedBy":"Jo\xe3o Paulo","lastUpdatedAt":1759068822000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Base class for clustering algorithm.","sidebar_label":"BaseClusterer","lastUpdatedAt":"2025/08/19","author":"Jo\xe3o Paulo","keywords":["Base Clusterer","Clustering","Unsupervised Learning","BaseClusterer","Abstract Base Class","fit Method","predict Method","fit_predict Method","AiNet","Cluster Prediction","Python ML Classes"]},"sidebar":"docs","previous":{"title":"BaseClassifier","permalink":"/docs/advanced-guides/base-module/Classifier"},"next":{"title":"BaseOptimizer","permalink":"/docs/advanced-guides/base-module/Optimizer"}}');var t=s(4848),i=s(8453);const d={sidebar_position:3,title:"Base class for clustering algorithm.",sidebar_label:"BaseClusterer",lastUpdatedAt:"2025/08/19",author:"Jo\xe3o Paulo",keywords:["Base Clusterer","Clustering","Unsupervised Learning","BaseClusterer","Abstract Base Class","fit Method","predict Method","fit_predict Method","AiNet","Cluster Prediction","Python ML Classes"]},l=void 0,c={},o=[{value:"<code>BaseClusterer(ABC, Base)</code>",id:"BaseClustererABC-Base",level:2},{value:"Function fit(...)",id:"Function-fit",level:3},{value:"Function predict(...)",id:"Function-predict",level:3},{value:"Function fit_predict(...)",id:"Function-fit_predict",level:3}];function a(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"BaseClustererABC-Base",children:(0,t.jsx)(n.code,{children:"BaseClusterer(ABC, Base)"})}),"\n",(0,t.jsx)(n.p,{children:"Abstract base class for clustering algorithms."}),"\n",(0,t.jsxs)(n.p,{children:["This class defines the core interface for clustering models. It enforces\nthe implementation of the ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"fit"})})," and ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"predict"})})," methods in all derived classes,\nand provides a default implementation for ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"fit_predict"})})," and ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"get_params"})}),"."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"Function-fit",children:"Function fit(...)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def fit(self, X: npt.NDArray, verbose: bool = True) -> BaseClusterer\n"})}),"\n",(0,t.jsx)(n.p,{children:"Fit the model to the training data.\nThis abstract method must be implemented by subclasses."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"X"})}),": ",(0,t.jsx)(n.code,{children:"npt.NDArray"}),"\nInput data used for training the model."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"verbose"})}),": ",(0,t.jsx)(n.code,{children:"bool"}),", default=True\nFlag to enable or disable detailed output during training."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"self"})}),":\nInstance of the class that implements this method."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Implementation"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/aisp-techniques/immune-network-theory/ainet#Function-fit",children:"AiNet"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"Function-predict",children:"Function predict(...)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def predict(self, X: npt.NDArray) -> Optional[npt.NDArray]\n"})}),"\n",(0,t.jsx)(n.p,{children:"Generate predictions based on the input data.\nThis abstract method must be implemented by subclasses."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"X"})}),": ",(0,t.jsx)(n.code,{children:"npt.NDArray"}),"\nInput data for which predictions will be generated."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"predictions"})}),": ",(0,t.jsx)(n.code,{children:"Optional[npt.NDArray]"}),"\nPredicted cluster labels for each input sample, or ",(0,t.jsx)(n.code,{children:"None"})," if prediction is not possible."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Implementation"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/docs/aisp-techniques/immune-network-theory/ainet#Function-predict",children:"AiNet"})}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"Function-fit_predict",children:"Function fit_predict(...)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"def fit_predict(self, X: npt.NDArray, verbose: bool = True) -> Optional[npt.NDArray]\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Convenience method that combines ",(0,t.jsx)(n.code,{children:"fit"})," and ",(0,t.jsx)(n.code,{children:"predict"})," in a single call."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Parameters"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"X"})}),": ",(0,t.jsx)(n.code,{children:"npt.NDArray"}),"\nInput data for which predictions will be generated."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"verbose"})}),": ",(0,t.jsx)(n.code,{children:"bool"}),", default=True\nFlag to enable or disable detailed output during training."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"predictions"})}),": ",(0,t.jsx)(n.code,{children:"Optional[npt.NDArray]"}),"\nPredicted cluster labels for each input sample, or ",(0,t.jsx)(n.code,{children:"None"})," if prediction is not possible."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>l});var r=s(6540);const t={},i=r.createContext(t);function d(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);