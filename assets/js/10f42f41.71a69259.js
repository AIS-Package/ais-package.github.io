"use strict";(self.webpackChunkais_project_github_io=self.webpackChunkais_project_github_io||[]).push([[322],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(n),m=i,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||r;return n?a.createElement(h,l(l({ref:t},c),{},{components:n})):a.createElement(h,l({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2935:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={id:"bnsa",title:"BNSA",sidebar_label:"BNSA - Binary Negative Selection Algorithm",sidebar_position:2,pagination_next:null,keywords:["Binary","classifying","anomalies","not self","affinity threshold"]},l="BNSA (Binary Negative Selection Algorithm)",o={unversionedId:"aisp-techniques/Negative Selection/bnsa",id:"aisp-techniques/Negative Selection/bnsa",title:"BNSA",description:"Constructor RNSA:",source:"@site/docs/aisp-techniques/Negative Selection/BNSA.md",sourceDirName:"aisp-techniques/Negative Selection",slug:"/aisp-techniques/Negative Selection/bnsa",permalink:"/docs/aisp-techniques/Negative Selection/bnsa",draft:!1,tags:[],version:"current",lastUpdatedBy:"Jo\xe3o Paulo",lastUpdatedAt:1743829618,formattedLastUpdatedAt:"Apr 5, 2025",sidebarPosition:2,frontMatter:{id:"bnsa",title:"BNSA",sidebar_label:"BNSA - Binary Negative Selection Algorithm",sidebar_position:2,pagination_next:null,keywords:["Binary","classifying","anomalies","not self","affinity threshold"]},sidebar:"tutorialSidebar",previous:{title:"RNSA - Real-Valued Negative Selection Algorithm",permalink:"/docs/aisp-techniques/Negative Selection/rnsa"}},s={},p=[{value:"Constructor RNSA:",id:"constructor-rnsa",level:2},{value:"Function fit(...)",id:"function-fit",level:3},{value:"Function predict(...)",id:"function-predict",level:3},{value:"Function score(...)",id:"function-score",level:3},{value:"Private Methods",id:"private-methods",level:2},{value:"Function __slice_index_list_by_class(...)",id:"function-__slice_index_list_by_class",level:3}],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"bnsa-binary-negative-selection-algorithm"},"BNSA (Binary Negative Selection Algorithm)"),(0,i.kt)("h2",{id:"constructor-rnsa"},"Constructor RNSA:"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"BNSA")," (Binary Negative Selection Algorithm) class has the purpose of classifying and identifying anomalies through the self and not self methods."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'class BNSA(\n    self, \n    N: int = 100, \n    aff_thresh: float = 0.1, \n    max_discards: int = 1000, \n    seed: int = None,\n    no_label_sample_selection: Literal["max_average_difference", "max_nearest_difference"] = "max_average_difference"\n)\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Attributes:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"N")," (",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"): Number of detectors. Defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"100"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"aff_thresh")," (",(0,i.kt)("inlineCode",{parentName:"p"},"float"),"): The variable ('affinity threshold') represents the percentage of dissimilarity between the T cell and the own samples. The default value is 10% (0.1), while a value of 1.0 represents 100% dissimilarity."),(0,i.kt)("admonition",{parentName:"li",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Setting the difference percentage too high can result in the inability to generate detectors for non-self."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"max_discards")," (",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"): This parameter indicates the maximum number of detector discards in sequence, which aims to avoid a\npossible infinite loop if a radius is defined that it is not possible to generate non-self detectors. Defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"1000"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"seed")," (",(0,i.kt)("inlineCode",{parentName:"p"},"int"),"): Seed for the random generation of values in the detectors. Defaults to ",(0,i.kt)("inlineCode",{parentName:"p"},"None"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"no_label_sample_selection (",(0,i.kt)("inlineCode",{parentName:"p"},"str"),"): Method for selecting labels for samples designated as non-members by all non-member detectors. ",(0,i.kt)("strong",{parentName:"p"},"Available method types:")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"(",(0,i.kt)("inlineCode",{parentName:"li"},"max_average_difference"),"): Selects the class with the highest average difference among the detectors."),(0,i.kt)("li",{parentName:"ul"},"(",(0,i.kt)("inlineCode",{parentName:"li"},"max_nearest_difference"),"): Selects the class with the highest difference between the nearest and farthest detector from the sample.")))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Other variables initiated:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"detectors")," (",(0,i.kt)("inlineCode",{parentName:"p"},"dict"),"): This variable stores a list of detectors by class.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"classes")," (",(0,i.kt)("inlineCode",{parentName:"p"},"npt.NDArray"),"): list of output classes."))),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"function-fit"},"Function fit(...)"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"fit(...)")," function generates the detectors for non-fits with respect to the samples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def fit(self, X: npt.NDArray, y: npt.NDArray):\n")),(0,i.kt)("p",null,"In it, training is performed according to ",(0,i.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"y"),", using the negative selection method(",(0,i.kt)("inlineCode",{parentName:"p"},"NegativeSelect"),")."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The input parameters are:")," "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"X"),": array with the characteristics of the samples with ",(0,i.kt)("strong",{parentName:"p"},"N")," samples (rows) and ",(0,i.kt)("strong",{parentName:"p"},"N")," characteristics (columns). ")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"y"),": array with the output classes arranged in ",(0,i.kt)("strong",{parentName:"p"},"N")," samples that are related to ",(0,i.kt)("inlineCode",{parentName:"p"},"X"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"verbose"),": boolean with default value ",(0,i.kt)("inlineCode",{parentName:"p"},"True"),", determines if the feedback from the detector generation will be printed."))),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Returns the instance of the class.")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"function-predict"},"Function predict(...)"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"predict(...)")," function performs class prediction using the generated detectors:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def predict(self, X: npt.NDArray) -> npt.NDArray:\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The input parameter is:")," "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"X"),": array with the characteristics for the prediction, with ",(0,i.kt)("strong",{parentName:"li"},"N")," samples (Rows) and ",(0,i.kt)("strong",{parentName:"li"},"N")," columns.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Returns:")," "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"C"),": prediction array, with the output classes for the given characteristics."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"None"),": if there are no detectors.")),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"function-score"},"Function score(...)"),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"score(...)")," calculates the accuracy of the trained model by making predictions and computing accuracy."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def score(self, X: npt.NDArray, y: list) -> float:\n")),(0,i.kt)("p",null,"It returns the accuracy as a float type."),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"private-methods"},"Private Methods"),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"function-__slice_index_list_by_class"},"Function __slice_index_list_by_class(...)"),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"__slice_index_list_by_class(...)"),", separates the indices of the lines according to the output class, to go through the sample array, only in the positions that the output is the class that is being trained:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"def __slice_index_list_by_class(self, y: npt.NDArray) -> dict:\n")),(0,i.kt)("p",null,"Returns a dictionary with the classes as key and the indices in ",(0,i.kt)("inlineCode",{parentName:"p"},"X")," of the samples."),(0,i.kt)("hr",null))}d.isMDXComponent=!0}}]);